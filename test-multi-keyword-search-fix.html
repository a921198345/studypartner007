<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å¤šå…³é”®è¯æœç´¢ä¿®å¤æµ‹è¯•</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .test-section {
      margin-bottom: 30px;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
    }
    .test-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    .test-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .keywords-display {
      display: flex;
      gap: 5px;
      margin: 10px 0;
    }
    .keyword-tag {
      padding: 4px 8px;
      background-color: #e3f2fd;
      color: #1976d2;
      border-radius: 4px;
      font-size: 14px;
    }
    input, select {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background-color: #45a049;
    }
    .results-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      margin-top: 20px;
    }
    .result-box {
      padding: 15px;
      background-color: #f9f9f9;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
    }
    .result-header {
      font-weight: bold;
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .result-count {
      font-size: 14px;
      color: #666;
      font-weight: normal;
    }
    .question-item {
      padding: 8px;
      margin-bottom: 6px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      font-size: 13px;
    }
    .question-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
      font-size: 12px;
      color: #666;
    }
    .question-text {
      font-size: 12px;
      line-height: 1.4;
      max-height: 40px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .highlight {
      background-color: #ffeb3b;
      padding: 1px 2px;
      border-radius: 2px;
    }
    .highlight-alt {
      background-color: #b3e5fc;
      padding: 1px 2px;
      border-radius: 2px;
    }
    .status {
      padding: 10px;
      margin-bottom: 20px;
      border-radius: 4px;
      font-size: 14px;
    }
    .status.info {
      background-color: #e3f2fd;
      color: #1976d2;
    }
    .status.success {
      background-color: #e8f5e9;
      color: #388e3c;
    }
    .status.error {
      background-color: #ffebee;
      color: #d32f2f;
    }
    .comparison {
      margin-top: 20px;
      padding: 15px;
      background-color: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 4px;
    }
    .loading {
      text-align: center;
      color: #666;
      padding: 20px;
    }
    .match-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-left: 5px;
    }
    .match-single { background-color: #4caf50; }
    .match-multi { background-color: #ff9800; }
    .match-all { background-color: #2196f3; }
  </style>
</head>
<body>
  <h1>å¤šå…³é”®è¯æœç´¢ä¿®å¤æµ‹è¯•</h1>
  
  <div class="container">
    <h2>æµ‹è¯•è¯´æ˜</h2>
    <p>æ­¤æµ‹è¯•é¡µé¢ç”¨äºéªŒè¯å¤šå…³é”®è¯æœç´¢çš„å¹¶é›†åŠŸèƒ½æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚</p>
    <ul>
      <li>ğŸŸ¢ å•å…³é”®è¯åŒ¹é… - é¢˜ç›®åªåŒ¹é…ä¸€ä¸ªå…³é”®è¯</li>
      <li>ğŸŸ  å¤šå…³é”®è¯åŒ¹é… - é¢˜ç›®åŒ¹é…å¤šä¸ªå…³é”®è¯ï¼ˆä¼˜å…ˆæ˜¾ç¤ºï¼‰</li>
      <li>ğŸ”µ å…¨éƒ¨åŒ¹é… - é¢˜ç›®åŒ¹é…æ‰€æœ‰å…³é”®è¯</li>
    </ul>
  </div>

  <div class="test-section">
    <div class="test-header">
      <div>
        <h3>å¤šå…³é”®è¯å¹¶é›†æœç´¢æµ‹è¯•</h3>
        <div class="keywords-display" id="keywords-display"></div>
      </div>
      <div class="test-controls">
        <select id="subject">
          <option value="all">å…¨éƒ¨ç§‘ç›®</option>
          <option value="æ°‘æ³•">æ°‘æ³•</option>
          <option value="åˆ‘æ³•" selected>åˆ‘æ³•</option>
          <option value="è¡Œæ”¿æ³•">è¡Œæ”¿æ³•</option>
        </select>
        <input type="text" id="keywords" placeholder="è¾“å…¥å…³é”®è¯ï¼Œé€—å·åˆ†éš”" value="ç›—çªƒ,æŠ¢åŠ«" style="width: 200px;">
        <button onclick="runTest()">å¼€å§‹æµ‹è¯•</button>
      </div>
    </div>

    <div id="status" class="status info">å‡†å¤‡å°±ç»ª</div>

    <div class="results-grid">
      <div class="result-box">
        <div class="result-header">
          <span>å…³é”®è¯1æœç´¢ç»“æœ</span>
          <span class="result-count" id="keyword1-count">-</span>
        </div>
        <div id="keyword1-results" class="loading">ç­‰å¾…æµ‹è¯•...</div>
      </div>
      <div class="result-box">
        <div class="result-header">
          <span>å…³é”®è¯2æœç´¢ç»“æœ</span>
          <span class="result-count" id="keyword2-count">-</span>
        </div>
        <div id="keyword2-results" class="loading">ç­‰å¾…æµ‹è¯•...</div>
      </div>
      <div class="result-box">
        <div class="result-header">
          <span>å¹¶é›†æœç´¢ç»“æœ</span>
          <span class="result-count" id="union-count">-</span>
        </div>
        <div id="union-results" class="loading">ç­‰å¾…æµ‹è¯•...</div>
      </div>
    </div>

    <div id="comparison" class="comparison" style="display: none;">
      <h3>æœç´¢ç»“æœåˆ†æ</h3>
      <div id="analysis-content"></div>
    </div>
  </div>

  <script>
    // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
    function updateStatus(message, type = 'info') {
      const statusEl = document.getElementById('status');
      statusEl.textContent = message;
      statusEl.className = `status ${type}`;
    }

    // æ˜¾ç¤ºå…³é”®è¯æ ‡ç­¾
    function displayKeywords(keywords) {
      const container = document.getElementById('keywords-display');
      container.innerHTML = keywords.map(kw => 
        `<span class="keyword-tag">${kw}</span>`
      ).join('');
    }

    // é«˜äº®å…³é”®è¯
    function highlightKeywords(text, keywords) {
      let highlightedText = text;
      keywords.forEach((keyword, index) => {
        if (keyword) {
          const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const className = index === 0 ? 'highlight' : 'highlight-alt';
          highlightedText = highlightedText.replace(
            new RegExp(`(${escapedKeyword})`, 'gi'),
            `<span class="${className}">$1</span>`
          );
        }
      });
      return highlightedText;
    }

    // æ£€æŸ¥é¢˜ç›®åŒ¹é…äº†å“ªäº›å…³é”®è¯
    function getMatchedKeywords(question, keywords) {
      const text = question.question_text.toLowerCase();
      return keywords.filter(kw => text.includes(kw.toLowerCase()));
    }

    // æ¸²æŸ“é¢˜ç›®åˆ—è¡¨
    function renderQuestions(questions, keywords, containerId, countId) {
      const container = document.getElementById(containerId);
      const countEl = document.getElementById(countId);
      
      if (!questions || questions.length === 0) {
        container.innerHTML = '<div class="loading">æ²¡æœ‰æ‰¾åˆ°é¢˜ç›®</div>';
        countEl.textContent = '0é“é¢˜';
        return;
      }

      countEl.textContent = `${questions.length}é“é¢˜`;

      // é™åˆ¶æ˜¾ç¤ºæ•°é‡
      const displayQuestions = questions.slice(0, 20);
      
      container.innerHTML = displayQuestions.map((q, index) => {
        const matchedKeywords = getMatchedKeywords(q, keywords);
        let matchClass = '';
        let matchIndicator = '';
        
        if (matchedKeywords.length === keywords.length) {
          matchClass = 'match-all';
          matchIndicator = '<span class="match-indicator match-all" title="åŒ¹é…æ‰€æœ‰å…³é”®è¯"></span>';
        } else if (matchedKeywords.length > 1) {
          matchClass = 'match-multi';
          matchIndicator = '<span class="match-indicator match-multi" title="åŒ¹é…å¤šä¸ªå…³é”®è¯"></span>';
        } else {
          matchClass = 'match-single';
          matchIndicator = '<span class="match-indicator match-single" title="åŒ¹é…å•ä¸ªå…³é”®è¯"></span>';
        }
        
        return `
          <div class="question-item ${matchClass}">
            <div class="question-header">
              <span>#${index + 1} - ID: ${q.id}${matchIndicator}</span>
              <span>${q.year || ''} ${q.subject || ''}</span>
            </div>
            <div class="question-text">
              ${highlightKeywords(q.question_text.substring(0, 100) + '...', keywords)}
            </div>
          </div>
        `;
      }).join('');
      
      if (questions.length > 20) {
        container.innerHTML += `<div class="loading">...è¿˜æœ‰ ${questions.length - 20} é“é¢˜ç›®</div>`;
      }
    }

    // æœç´¢å•ä¸ªå…³é”®è¯
    async function searchSingleKeyword(keyword, subject) {
      try {
        const params = new URLSearchParams({
          subject: subject !== 'all' ? subject : '',
          search: keyword,
          page: '1',
          limit: '100'
        });
        
        const response = await fetch(`/api/exams/questions?${params}`);
        const data = await response.json();
        
        if (data.success) {
          return data.data.questions;
        } else {
          throw new Error(data.message || 'æœç´¢å¤±è´¥');
        }
      } catch (error) {
        console.error(`æœç´¢å…³é”®è¯ "${keyword}" å¤±è´¥:`, error);
        return [];
      }
    }

    // æ¨¡æ‹ŸAIè·³è½¬çš„å¹¶é›†æœç´¢
    async function searchUnion(keywords, subject) {
      try {
        updateStatus(`æ­£åœ¨æ‰§è¡Œå¤šå…³é”®è¯å¹¶é›†æœç´¢...`, 'info');
        
        // æ„å»ºURLå‚æ•°ï¼Œæ¨¡æ‹Ÿä»AIèŠå¤©è·³è½¬
        const jumpUrl = `/question-bank?subject=${subject}&keywords=${keywords.join(',')}&source=ai-chat`;
        console.log('æ¨¡æ‹Ÿè·³è½¬URL:', jumpUrl);
        
        // ç›´æ¥è°ƒç”¨APIè¿›è¡Œå¤šå…³é”®è¯æœç´¢
        const allQuestions = new Map();
        
        // å¹¶è¡Œæœç´¢æ‰€æœ‰å…³é”®è¯
        const searchPromises = keywords.map(keyword => searchSingleKeyword(keyword, subject));
        const searchResults = await Promise.all(searchPromises);
        
        // åˆå¹¶ç»“æœ
        searchResults.forEach((questions, index) => {
          questions.forEach(q => {
            if (!allQuestions.has(q.id)) {
              allQuestions.set(q.id, {
                ...q,
                matched_keywords: [keywords[index]]
              });
            } else {
              const existing = allQuestions.get(q.id);
              if (!existing.matched_keywords.includes(keywords[index])) {
                existing.matched_keywords.push(keywords[index]);
              }
            }
          });
        });
        
        // è½¬æ¢ä¸ºæ•°ç»„å¹¶æŒ‰åŒ¹é…æ•°é‡æ’åº
        const mergedQuestions = Array.from(allQuestions.values())
          .sort((a, b) => {
            const scoreA = a.matched_keywords.length;
            const scoreB = b.matched_keywords.length;
            if (scoreB !== scoreA) return scoreB - scoreA;
            return a.id - b.id;
          });
        
        return mergedQuestions;
      } catch (error) {
        console.error('å¹¶é›†æœç´¢é”™è¯¯:', error);
        updateStatus('å¹¶é›†æœç´¢å¤±è´¥: ' + error.message, 'error');
        return [];
      }
    }

    // åˆ†ææœç´¢ç»“æœ
    function analyzeResults(keyword1Results, keyword2Results, unionResults, keywords) {
      const analysisEl = document.getElementById('analysis-content');
      
      const k1Ids = new Set(keyword1Results.map(q => q.id));
      const k2Ids = new Set(keyword2Results.map(q => q.id));
      const unionIds = new Set(unionResults.map(q => q.id));
      
      // è®¡ç®—äº¤é›†å’Œå·®é›†
      const intersection = [...k1Ids].filter(id => k2Ids.has(id));
      const onlyInK1 = [...k1Ids].filter(id => !k2Ids.has(id));
      const onlyInK2 = [...k2Ids].filter(id => !k1Ids.has(id));
      
      // éªŒè¯å¹¶é›†æ˜¯å¦æ­£ç¡®
      const expectedUnionSize = k1Ids.size + k2Ids.size - intersection.length;
      const isUnionCorrect = unionIds.size === expectedUnionSize;
      
      let html = `
        <div>
          <p><strong>å…³é”®è¯1 "${keywords[0]}":</strong> ${k1Ids.size} é“é¢˜</p>
          <p><strong>å…³é”®è¯2 "${keywords[1]}":</strong> ${k2Ids.size} é“é¢˜</p>
          <p><strong>äº¤é›†ï¼ˆåŒæ—¶åŒ…å«ä¸¤ä¸ªå…³é”®è¯ï¼‰:</strong> ${intersection.length} é“é¢˜</p>
          <p><strong>å¹¶é›†ï¼ˆåŒ…å«ä»»ä¸€å…³é”®è¯ï¼‰:</strong> ${unionIds.size} é“é¢˜</p>
        </div>
        
        <div style="margin-top: 15px;">
          <p><strong>å¹¶é›†éªŒè¯:</strong></p>
          <p>é¢„æœŸå¹¶é›†å¤§å°: ${k1Ids.size} + ${k2Ids.size} - ${intersection.length} = ${expectedUnionSize}</p>
          <p>å®é™…å¹¶é›†å¤§å°: ${unionIds.size}</p>
          <p>ç»“æœ: ${isUnionCorrect ? 
            '<span style="color: green;">âœ… å¹¶é›†è®¡ç®—æ­£ç¡®</span>' : 
            '<span style="color: red;">âŒ å¹¶é›†è®¡ç®—æœ‰è¯¯</span>'}</p>
        </div>
      `;
      
      if (!isUnionCorrect) {
        // æ‰¾å‡ºå·®å¼‚
        const missingInUnion = [...k1Ids, ...k2Ids].filter(id => !unionIds.has(id));
        const extraInUnion = [...unionIds].filter(id => !k1Ids.has(id) && !k2Ids.has(id));
        
        if (missingInUnion.length > 0) {
          html += `<p style="color: red;">ç¼ºå¤±çš„é¢˜ç›®ID: ${missingInUnion.join(', ')}</p>`;
        }
        if (extraInUnion.length > 0) {
          html += `<p style="color: red;">å¤šä½™çš„é¢˜ç›®ID: ${extraInUnion.join(', ')}</p>`;
        }
      }
      
      // æ˜¾ç¤ºæ’åºæƒ…å†µ
      const multiMatchCount = unionResults.filter(q => 
        q.matched_keywords && q.matched_keywords.length > 1
      ).length;
      
      html += `
        <div style="margin-top: 15px;">
          <p><strong>æ’åºéªŒè¯:</strong></p>
          <p>åŒ¹é…å¤šä¸ªå…³é”®è¯çš„é¢˜ç›®: ${multiMatchCount} é“</p>
          <p>è¿™äº›é¢˜ç›®åº”è¯¥æ’åœ¨å‰é¢</p>
        </div>
      `;
      
      analysisEl.innerHTML = html;
      document.getElementById('comparison').style.display = 'block';
    }

    // è¿è¡Œæµ‹è¯•
    async function runTest() {
      const subject = document.getElementById('subject').value;
      const keywordsInput = document.getElementById('keywords').value.trim();
      
      if (!keywordsInput) {
        updateStatus('è¯·è¾“å…¥å…³é”®è¯', 'error');
        return;
      }
      
      // è§£æå…³é”®è¯
      const keywords = keywordsInput.split(',').map(k => k.trim()).filter(k => k);
      
      if (keywords.length < 2) {
        updateStatus('è¯·è¾“å…¥è‡³å°‘ä¸¤ä¸ªå…³é”®è¯ï¼Œç”¨é€—å·åˆ†éš”', 'error');
        return;
      }
      
      displayKeywords(keywords);
      
      // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
      ['keyword1-results', 'keyword2-results', 'union-results'].forEach(id => {
        document.getElementById(id).innerHTML = '<div class="loading">æœç´¢ä¸­...</div>';
      });
      document.getElementById('comparison').style.display = 'none';
      
      updateStatus(`æ­£åœ¨æœç´¢ ${keywords.join('ã€')} ç›¸å…³é¢˜ç›®...`, 'info');
      
      // å¹¶è¡Œæ‰§è¡Œä¸‰ç§æœç´¢
      const [keyword1Results, keyword2Results, unionResults] = await Promise.all([
        searchSingleKeyword(keywords[0], subject),
        searchSingleKeyword(keywords[1], subject),
        searchUnion(keywords.slice(0, 2), subject) // åªä½¿ç”¨å‰ä¸¤ä¸ªå…³é”®è¯è¿›è¡Œæµ‹è¯•
      ]);
      
      // æ¸²æŸ“ç»“æœ
      renderQuestions(keyword1Results, [keywords[0]], 'keyword1-results', 'keyword1-count');
      renderQuestions(keyword2Results, [keywords[1]], 'keyword2-results', 'keyword2-count');
      renderQuestions(unionResults, keywords.slice(0, 2), 'union-results', 'union-count');
      
      // åˆ†æç»“æœ
      analyzeResults(keyword1Results, keyword2Results, unionResults, keywords);
      
      updateStatus('æµ‹è¯•å®Œæˆ', 'success');
    }
  </script>
</body>
</html>