# 知识导图状态恢复 - 最终解决方案

## 问题总结
经过多次尝试，我们发现react-d3-tree库本身不支持状态恢复，它会在初始化时覆盖我们设置的任何展开状态。

## 根本解决方案

### 方案一：替换为支持状态管理的库（推荐）

使用 **antd 的 Tree 组件** 或 **rc-tree**：

```jsx
import { Tree } from 'antd';

const MindMapViewer = ({ subject, onNodeSelect }) => {
    const [expandedKeys, setExpandedKeys] = useState([]);
    const [selectedKeys, setSelectedKeys] = useState([]);
    
    // 从sessionStorage恢复状态
    useEffect(() => {
        const saved = sessionStorage.getItem(`treeState_${subject}`);
        if (saved) {
            const { expanded, selected } = JSON.parse(saved);
            setExpandedKeys(expanded);
            setSelectedKeys(selected);
        }
    }, [subject]);
    
    // 保存状态
    const saveState = () => {
        sessionStorage.setItem(`treeState_${subject}`, JSON.stringify({
            expanded: expandedKeys,
            selected: selectedKeys
        }));
    };
    
    return (
        <Tree
            treeData={treeData}
            expandedKeys={expandedKeys}
            selectedKeys={selectedKeys}
            onExpand={(keys) => {
                setExpandedKeys(keys);
                saveState();
            }}
            onSelect={(keys, info) => {
                setSelectedKeys(keys);
                saveState();
                onNodeSelect(info.node);
            }}
        />
    );
};
```

### 方案二：使用D3.js直接实现（完全控制）

```jsx
import * as d3 from 'd3';

const MindMapViewer = ({ data }) => {
    const svgRef = useRef();
    const [expandedNodes, setExpandedNodes] = useState(new Set());
    
    useEffect(() => {
        if (!data) return;
        
        const svg = d3.select(svgRef.current);
        const root = d3.hierarchy(data);
        
        // 根据expandedNodes设置节点状态
        root.each(node => {
            if (!expandedNodes.has(node.data.id)) {
                node._children = node.children;
                node.children = null;
            }
        });
        
        // 创建树布局
        const treeLayout = d3.tree()
            .size([height, width]);
            
        // 更新节点位置
        treeLayout(root);
        
        // 渲染节点和连线
        // ... D3渲染代码
        
    }, [data, expandedNodes]);
    
    return <svg ref={svgRef} />;
};
```

### 方案三：保持现有方案但改变交互模式

不依赖自动恢复，而是提供用户友好的导航：

1. **面包屑导航**：显示当前路径，点击可快速跳转
2. **搜索定位**：输入节点名称，自动展开并定位
3. **收藏夹**：让用户收藏常用节点路径
4. **历史记录**：记录最近访问的节点

```jsx
// 添加面包屑导航
const Breadcrumb = ({ path, onNavigate }) => (
    <div className="breadcrumb">
        {path.map((node, index) => (
            <span key={index}>
                <button onClick={() => onNavigate(node)}>
                    {node.name}
                </button>
                {index < path.length - 1 && ' > '}
            </span>
        ))}
    </div>
);

// 添加快速搜索
const QuickSearch = ({ onSearch }) => (
    <input
        type="text"
        placeholder="搜索知识点..."
        onChange={(e) => onSearch(e.target.value)}
    />
);
```

## 建议

1. **短期**：实现方案三，提供更好的导航体验，避免用户需要重复展开
2. **中期**：评估antd Tree或其他成熟组件库
3. **长期**：如果需要高度定制化，使用D3.js重新实现

## 为什么原方案失败

1. react-d3-tree内部状态管理是封闭的
2. 组件生命周期与状态恢复时机冲突
3. 强制DOM操作不可靠且容易被覆盖
4. 库本身的设计理念不支持外部状态控制

## 行动计划

1. 先实现搜索和面包屑导航，改善用户体验
2. 收集用户反馈，确定是否需要完整的状态恢复
3. 如果确实需要，计划迁移到更合适的组件库